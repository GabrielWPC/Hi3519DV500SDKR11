## I. Overview

### 1.1 Introduction
This directory provides a set of scripts for building images. The following types of images are supported:
- Non-Secure image
- Secure images
Before building, configuration file is needed. The template of the configuration file can be generated by the script.

### 1.2 Scope
Scripts in this directory are invoked by OEM and third party to build single-signed images and double sign the built images respectively.

|    User     |             Operation            |
|-------------|----------------------------------|
| OEM         | build single-signed images       |
| Third party | double sign the built images     |

Dual signatures are optional based on demands.

### 1.3 Secure Boot Feature
- There are two security modes: Non-Secure and Secure.
- There are two types of start flows: Non-TEE and TEE. Their startup sequence is as follows:

|  Start Flow  |          Startup Sequence               |
|--------------|-----------------------------------------|
|   Non-TEE    |  GSL -> U-Boot -> ATF -> Linux          |
|     TEE      |  GSL -> U-Boot -> ATF-> TEE-OS -> Linux |

- Images in different modes take the following characteristics:

| Security Mode  | Start Flow |         Target Image          | Sign? | Encrypt? | Support OP-TEE? |
|----------------|------------|-------------------------------|-------|----------|-----------------|
|   Non-Secure   |  Non-TEE   | boot_image.bin                |  No   |    No    |      No         |
|   Secure       |  Non-TEE   | boot_image.bin                |  Yes  |    Yes   |      No         |
|   Secure       |  TEE       | boot_image.bin, tee_image.bin |  Yes  |    Yes   |      Yes        |

Note:
(1) "boot_image.bin" contains GSL and U-Boot codes.
(2) "tee_image.bin" contains ATF and OP-TEE codes.
(3) In secure mode, the GSL and U-Boot codes in boot_image.bin can be configured as non-encrypted.

### 1.4 Subsequent Contents
- Section 2 shows how to generate configuration files, built target images and double sign.
- Section 3 discribes the way to burn images;
- Section 4 shows directory structure and introducts functions of directories and files.


## II. Build Images

### 2.1 OEM Build Single-Signed Images

(1) Invoke the script to generate the configuration template "oem/oem_config.json".
```bash
$ python oem/oem_main.py gencfg oem/oem_config.json
```

(2) Referring to the chapter about "Script Configuration Description" of "User references of hi35xxVxx Secure Boot", replace the contents enclosed by "/*" and "*/" in "oem/oem_config.json".

(3) Invoke the script to build target images.
```bash
$ python oem/oem_main.py build oem/oem_config.json
```

Target images are output to "image/oem/". If dual signatures are required, please provide the target images for third party.

(4) (Optional) OTP burning and mirroring check

```bash
# non-tee
$ python oem/oem_main.py check oem/otp_check.json image/oem/boot_image.bin

# The tee function is enabled and a TEE image is generated.
$ python oem/oem_main.py check oem/otp_check.json image/oem/boot_image.bin image/oem/tee_image.bin
```

Check the script for verifying the boot image and teeos image, and check if the otp burn value and image match. Note that:
- oem/otp_check.json is the otp configuration file, which needs to be filled in according to the burn value of otp before use.
- image/oem/boot_image.bin is the boot image.
- image/oem/tee_image.bin (optional) is the tee image.

Pay attention to the error print in the log. The check tool does not stop immediately when an error occurs. It checks as many fields as possible.

Error notification can remind for the following errors:
- The OTP verification function is enabled, but an error occurs when the OTP verification function is enabled.
- The hash values of the root (ree, tee) public key area do not match.
- mrk1 OTP burning error, image decryption failed.
- tee: OTP burning is enabled but the signature is not verified.
- dec_enable OTP is burnt, but the image is not encrypted.

Full-field image dump is supported for customers to debug their own image creation scripts.
If you need to customize the image creation script, delete the following comments: Prints the fields in each area.

```python
def __check_flash_root_pub_key_area(self, flash_root_pub_key_area, image_bytes, hash_val):
# flash_root_pub_key_area.dump()

def __check_area(self, area, image_bytes):
# area.dump()

def __checkout_key_area(self, key_area, image_bytes, pub_key = None):
# key_area.dump()

def __checkout_code_info_area(self, info_area, image_bytes, pub_key = None):
# info_area.dump()

def __checkout_code_area(self, code_area, image_bytes, hash_val = None, dec_tool = None):
# code_area.dump()
```

In encryption and decryption scenarios:
Copy KDF_Linux_SecureBoot and parameter.bin in ../kdf_customer/ to the local directory(image_tool).

### 2.2 Third party Double Sign

(1) Invoke the script to generate the configuration template "third_party_owner/third_party_config.json".
```bash
$ python third_party/third_party_main.py gencfg third_party/third_party_config.json
```

(2) Referring to the chapter about "Script Configuration Description" of "hi35xxVxx Secure Boot User References",replace the contents enclosed by "/*" and "*/" in "third_party/third_party_config.json".

(3) Put images built by OEM in the "image/oem/" directory, including:
- boot_image.bin
- tee_image.bin (required only when using TEE Start Flow)

(4) Invoke the script to sign images built by OEM.
```bash
$ python third_party/third_party_main.py build third_party/third_party_config.json
```

Dual-signed target images are ouput to "image/third_party/".


## 3. Image Burning Description

(1) In the non-TEE boot scenario, burn the following content:

|   Image to Burn   |    Components     |
|-------------------|-------------------|
| boot_image.bin    | GSL and U-Boot    |
| uImage_ss626v100  | ATF and  Linux    |
| RootFS Image      | Root File System  |


(2) In the TEE startup scenario, burn the following images:

|   Image to Burn   |    Components     |
|-------------------|-------------------|
| boot_image.bin    | GSL, U-Boot       |
| uImage            | Linux             |
| RootFS Image      | Root File System  |
| tee_image.bin     | ATF, OP-TEE       |


## 4. Directory Structure

The subdirectories of the top-level directory are as follows:
- common/
- oem/
- third_party/
- image/

### 4.1 common/
provide the following functions for generating images:
- util.py: binary data processing, converting endian, and file operation etc.
- check.py: number format check, file check etc.
- area_tool.py: protection key encryption and Root_Public_Key Area generation etc.
- config.py: configuration file generation and parsing, and configuration item error detection, etc.
- logger.py: recording logs.
- secure.py: signing, hashing, and encryption.
- clean.py: cleaning ouput files.

### 4.2 oem/
- oem_main.py
Script invoked by OEM users to make OEM areas and single-signed target images.
- oem_quick_build.py
Script for generating an non-secure "boot_image.bin".
- quick_build_config.json
Configuration file for generating an non-secure "boot_image.bin".
- tools/
Contains a collection of subscripts invoked by oem_main.py to generate configuration file templates, binary area files, and target images.
- tmp/
Directory of the intermediate generated files.

### 4.3 third_party/
- third_party_main.py
Script invoked by a third party user to make third party areas and double sign images.
- tools/
Contains a collection of subscripts invoked by third_party_main.py to generate configuration file templates, binary area files, and dual-signd target images.
- tmp/
Directory of intermediate generated files.


### 4.4 image/
Directory of target images.
